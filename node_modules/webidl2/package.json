{
  "name": "webidl2",
  "description": "A WebIDL Parser",
  "version": "2.0.11",
  "author": {
    "name": "Robin Berjon",
    "email": "robin@berjon.com"
  },
  "license": "MIT",
  "dependencies": {},
  "devDependencies": {
    "mocha": "2.2.5",
    "expect.js": "0.3.1",
    "underscore": "1.8.3",
    "jsondiffpatch": "0.1.31",
    "benchmark": "*",
    "microtime": "1.4.2"
  },
  "scripts": {
    "test": "mocha"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/darobin/webidl2.js"
  },
  "main": "index",
  "readme": "\n# WebIDL 2\n\n[![NPM version](https://badge.fury.io/js/webidl2.png)](http://badge.fury.io/js/webidl2)\n\nPurpose\n=======\n\nThis is a parser for the [WebIDL](http://dev.w3.org/2006/webapi/WebIDL/) language. If\nyou don't know what that is, then you probably don't need it. It is meant to be used\nboth in Node and in the browser (the parser likely works in other JS environments, but\nnot the test suite).\n\nWhat of v1?\n-----------\nThere was a previous incarnation of this project. I had written it in the most quick\nand dirty manner that was handy because I required it as a dependency in an experiment.\nAs these things tend to happen, some people started using that, which then had to be\nmaintained. But since it was not built on solid foundations, it was painful to keep\nup to date with the specification, which is a bit of a moving target.\n\nSo I started from scratch. Compared to the previous version (which used a parser generator)\nthis one is about 6x less code (which translates to 4x smaller minified or 2x smaller \nminizipped) and 4x faster. The test suite is reasonably complete (95% coverage), much more\nthan previously. This version is up to date with WebIDL, rather than a couple years' behind.\nIt also has *far* better error reporting.\n\nThe AST you get from parsing is very similar to the one you got in v1, but some adjustments \nhave been made in order to be more systematic, and to map better to what's actually in the spec \nnow. If you used v1, you will need to tweak your code but the result ought to be simpler and\nyou ought to be able to be a fair bit less defensive against irregularities in the way \ninformation is represented.\n\nInstallation\n============\n\nJust the usual. For Node:\n\n    npm install webidl2\n    \nIn the browser:\n\n    <script src='webidl2.js'></script>\n\nDocumentation\n=============\n\nThe API to WebIDL2 is trivial: you parse a string of WebIDL and it returns a syntax tree.\n\nParsing\n-------\nIn Node, that happens with:\n\n    var WebIDL2 = require(\"webidl2\");\n    var tree = WebIDL2.parse(\"string of WebIDL\");\n\nIn the browser:\n\n    <script src='webidl2.js'></script>\n    <script>\n      var tree = WebIDL2.parse(\"string of WebIDL\");\n    </script>\n\nAdvanced Parsing\n----------------\n\n`parse()` can optionally accept a second parameter, an options object, which can be used to\nmodify parsing behavior.\n\nThe following options are recognized:\n```javascript\n{\n    allowNestedTypedefs: false # \n}\n```\nAnd their meanings are as follows:\n\n* `allowNestedTypedefs`: Boolean indicating whether the parser should accept `typedef`s as valid members of `interface`s. This is non-standard syntax and therefore the default is `false`.\n\nErrors\n------\nWhen there is a syntax error in the WebIDL, it throws an exception object with the following\nproperties:\n\n* `message`: the error message\n* `line`: the line at which the error occurred.\n* `input`: a short peek at the text at the point where the error happened\n* `tokens`: the five tokens at the point of error, as understood by the tokeniser\n  (this is the same content as `input`, but seen from the tokeniser's point of view)\n\nThe exception also has a `toString()` method that hopefully should produce a decent\nerror message.\n\nAST (Abstract Syntax Tree)\n--------------------------\nThe `parse()` method returns a tree object representing the parse tree of the IDL.\nComment and white space are not represented in the AST.\n\nThe root of this object is always an array of definitions (where definitions are\nany of interfaces, exceptions, callbacks, etc. â€” anything that can occur at the root\nof the IDL).\n\n### IDL Type\n\nThis structure is used in many other places (operation return types, argument types, etc.).\nIt captures a WebIDL type with a number of options. Types look like this and are typically\nattached to a field called `idlType`:\n\n    {\n        \"sequence\": false,\n        \"generic\": null,\n        \"nullable\": false,\n        \"array\": false,\n        \"union\": false,\n        \"idlType\": \"void\"\n    }\n\nWhere the fields are as follows:\n\n* `sequence`: Boolean indicating whether this is a sequence or not. Deprecated. Use\n  `generic` instead.\n* `generic`: String indicating the generic type (e.g. \"Promise\", \"sequence\"). `null`\n  otherwise.\n* `nullable`: Boolean indicating whether this is nullable or not.\n* `array`: Either `false` to indicate that it is not an array, or a number for the level of\n  array nesting.\n* `union`: Boolean indicating whether this is a union type or not.\n* `idlType`: Can be different things depending on context. In most cases, this will just\n  be a string with the type name. But the reason this field isn't called \"typeName\" is\n  because it can take more complex values. If the type is a union, then this contains an\n  array of the types it unites. If it is a generic type, it contains the IDL type\n  description for the type in the sequence, the eventual value of the promise, etc.\n\n#### Interactions between `nullable` and `array`\n\nA more complex data model for our AST would likely represent `Foo[][][]` as a series of\nnested types four levels deep with three anonymous array types eventually containing a \n`Foo` type. But experience shows that such structures are cumbersome to use, and so we\nhave a simpler model in which the depth of the array is specified with the `array` field.\n\nThis is all fine and well, and in the vast majority of cases is actually simpler. But it\ndoes run afoul of cases in which it is necessary to distinguish between `Foo[][][]?`,\n`Foo?[][][]`, `Foo[][]?[]`, or even `Foo?[]?[]?[]?`.\n\nFor this, when a type is an array type an additional `nullableArray` field is made available\nthat captures which of the arrays contain nullable elements. It contains booleans that are\ntrue if the given array depth contains nullable elements, and false otherwise (mapping that to\nthe syntax, and item is true if there is a `?` preceding the `[]`). These examples ought to\nclarify the model:\n\n    Foo[][][]?\n        -> nullable: true\n        -> nullableArray: [false, false, false]\n    Foo?[][][]\n        -> nullable: false\n        -> nullableArray: [true, false, false]\n    Foo[][]?[]\n        -> nullable: false\n        -> nullableArray: [false, false, true]\n    Foo?[]?[]?[]?\n        -> nullable: true\n        -> nullableArray: [true, true, true]\n\nOf particular importance, please note that the overall type is only `nullable` if there is\na `?` at the end.\n\n### Interface\nInterfaces look like this:\n\n    {\n        \"type\": \"interface\",\n        \"name\": \"Animal\",\n        \"partial\": false,\n        \"members\": [...],\n        \"inheritance\": null,\n        \"extAttrs\": [...]\n    },\n    {\n        \"type\": \"interface\",\n        \"name\": \"Human\",\n        \"partial\": false,\n        \"members\": [...],\n        \"inheritance\": \"Animal\",\n        \"extAttrs\": [...]\n    }\n\nThe fields are as follows:\n\n* `type`: Always \"interface\".\n* `name`: The name of the interface\n* `partial`: A boolean indicating whether it's a partial interface.\n* `members`: An array of interface members (attributes, operations, etc.). Empty if there are none.\n* `inheritance`: A string giving the name of an interface this one inherits from, `null` otherwise.\n  **NOTE**: In v1 this was an array, but multiple inheritance is no longer supported so this didn't make\n  sense.\n* `extAttrs`: A list of [extended attributes](#extended-attributes).\n\n### Callback Interfaces\n\nThese are captured by the same structure as [Interfaces](#interface) except that\ntheir `type` field is \"callback interface\".\n\n### Callback\n\nA callback looks like this:\n\n  {\n      \"type\": \"callback\",\n      \"name\": \"AsyncOperationCallback\",\n      \"idlType\": {\n          \"sequence\": false,\n          \"generic\": null,\n          \"nullable\": false,\n          \"array\": false,\n          \"union\": false,\n          \"idlType\": \"void\"\n      },\n      \"arguments\": [...],\n      \"extAttrs\": []\n  }\n\nThe fields are as follows:\n\n* `type`: Always \"callback\".\n* `name`: The name of the callback.\n* `idlType`: An [IDL Type](#idl-type) describing what the callback returns.\n* `arguments`: A list of [arguments](#arguments), as in function paramters.\n* `extAttrs`: A list of [extended attributes](#extended-attributes).\n\n### Dictionary\n\nA dictionary looks like this:\n\n    {\n        \"type\": \"dictionary\",\n        \"name\": \"PaintOptions\",\n        \"partial\": false,\n        \"members\": [\n            {\n                \"type\": \"field\",\n                \"name\": \"fillPattern\",\n                \"required\": false,\n                \"idlType\": {\n                    \"sequence\": false,\n                    \"generic\": null,\n                    \"nullable\": true,\n                    \"array\": false,\n                    \"union\": false,\n                    \"idlType\": \"DOMString\"\n                },\n                \"extAttrs\": [],\n                \"default\": {\n                    \"type\": \"string\",\n                    \"value\": \"black\"\n                }\n            }\n        ],\n        \"inheritance\": null,\n        \"extAttrs\": []\n    }\n\nThe fields are as follows:\n\n* `type`: Always \"dictionary\".\n* `name`: The dictionary name.\n* `partial`: Boolean indicating whether it's a partial dictionary.\n* `members`: An array of members (see below).\n* `inheritance`: A string indicating which dictionary is being inherited from, `null` otherwise.\n* `extAttrs`: A list of [extended attributes](#extended-attributes).\n\nAll the members are fields as follows:\n\n* `type`: Always \"field\".\n* `name`: The name of the field.\n* `required`: Boolean indicating whether this is a [required](https://heycam.github.io/webidl/#required-dictionary-member) field.\n* `idlType`: An [IDL Type](#idl-type) describing what field's type.\n* `extAttrs`: A list of [extended attributes](#extended-attributes).\n* `default`: A [default value](#default-and-const-values), absent if there is none.\n\n### Exception\n\nAn exception looks like this:\n\n    {\n        \"type\": \"exception\",\n        \"name\": \"HierarchyRequestError\",\n        \"members\": [\n            {\n                \"type\": \"field\",\n                \"name\": \"code\",\n                \"idlType\": {\n                    \"sequence\": false,\n                    \"generic\": null,\n                    \"nullable\": false,\n                    \"array\": false,\n                    \"union\": false,\n                    \"idlType\": \"unsigned short\"\n                },\n                \"extAttrs\": []\n            }\n        ],\n        \"inheritance\": \"DOMException\",\n        \"extAttrs\": []\n    }\n\nThe fields are as follows:\n\n* `type`: Always \"exception\".\n* `name`: The exception name.\n* `members`: An array of members (constants or fields, where fields are described below).\n* `inheritance`: A string indicating which exception is being inherited from, `null` otherwise.\n* `extAttrs`: A list of [extended attributes](#extended-attributes).\n\nMembers that aren't [constants](#constants) have the following fields:\n\n* `type`: Always \"field\".\n* `name`: The field's name.\n* `idlType`: An [IDL Type](#idl-type) describing what field's type.\n* `extAttrs`: A list of [extended attributes](#extended-attributes).\n\n### Enum\n\nAn enum looks like this:\n\n    {\n        \"type\": \"enum\",\n        \"name\": \"MealType\",\n        \"values\": [\n            \"rice\",\n            \"noodles\",\n            \"other\"\n        ],\n        \"extAttrs\": []\n    }\n\nThe fields are as follows:\n\n* `type`: Always \"enum\".\n* `name`: The enum's name.\n* `value`: An array of values (strings).\n* `extAttrs`: A list of [extended attributes](#extended-attributes).\n\n### Typedef\n\nA typedef looks like this:\n\n    {\n        \"type\": \"typedef\",\n        \"typeExtAttrs\": [],\n        \"idlType\": {\n            \"sequence\": true,\n            \"generic\": \"sequence\",\n            \"nullable\": false,\n            \"array\": false,\n            \"union\": false,\n            \"idlType\": {\n                \"sequence\": false,\n                \"generic\": null,\n                \"nullable\": false,\n                \"array\": false,\n                \"union\": false,\n                \"idlType\": \"Point\"\n            }\n        },\n        \"name\": \"PointSequence\",\n        \"extAttrs\": []\n    }\n\nThe fields are as follows:\n\n* `type`: Always \"typedef\".\n* `name`: The typedef's name.\n* `idlType`: An [IDL Type](#idl-type) describing what typedef's type.\n* `extAttrs`: A list of [extended attributes](#extended-attributes).\n* `typeExtAttrs`: A list of [extended attributes](#extended-attributes) that apply to the \ntype rather than to the typedef as a whole.\n\n### Implements\n\nAn implements definition looks like this:\n\n    {\n        \"type\": \"implements\",\n        \"target\": \"Node\",\n        \"implements\": \"EventTarget\",\n        \"extAttrs\": []\n    }\n\nThe fields are as follows:\n\n* `type`: Always \"implements\".\n* `target`: The interface that implements another.\n* `implements`: The interface that is being implemented by the target.\n* `extAttrs`: A list of [extended attributes](#extended-attributes).\n\n### Operation Member\n\nAn operation looks like this:\n\n    {\n        \"type\": \"operation\",\n        \"getter\": false,\n        \"setter\": false,\n        \"creator\": false,\n        \"deleter\": false,\n        \"legacycaller\": false,\n        \"static\": false,\n        \"stringifier\": false,\n        \"idlType\": {\n            \"sequence\": false,\n            \"generic\": null,\n            \"nullable\": false,\n            \"array\": false,\n            \"union\": false,\n            \"idlType\": \"void\"\n        },\n        \"name\": \"intersection\",\n        \"arguments\": [\n            {\n                \"optional\": false,\n                \"variadic\": true,\n                \"extAttrs\": [],\n                \"idlType\": {\n                    \"sequence\": false,\n                    \"generic\": null,\n                    \"nullable\": false,\n                    \"array\": false,\n                    \"union\": false,\n                    \"idlType\": \"long\"\n                },\n                \"name\": \"ints\"\n            }\n        ],\n        \"extAttrs\": []\n    }\n\nThe fields are as follows:\n\n* `type`: Always \"operation\".\n* `getter`: True if a getter operation.\n* `setter`: True if a setter operation.\n* `creator`: True if a creator operation.\n* `deleter`: True if a deleter operation.\n* `legacycaller`: True if a legacycaller operation.\n* `static`: True if a static operation.\n* `stringifier`: True if a stringifier operation.\n* `idlType`: An [IDL Type](#idl-type) of what the operation returns. If a stringifier, may be absent.\n* `name`: The name of the operation. If a stringifier, may be `null`.\n* `arguments`: An array of [arguments](#arguments) for the operation.\n* `extAttrs`: A list of [extended attributes](#extended-attributes).\n\n### Attribute Member\n\nAn attribute member looks like this:\n\n    {\n        \"type\": \"attribute\",\n        \"static\": false,\n        \"stringifier\": false,\n        \"inherit\": false,\n        \"readonly\": false,\n        \"idlType\": {\n            \"sequence\": false,\n            \"generic\": null,\n            \"nullable\": false,\n            \"array\": false,\n            \"union\": false,\n            \"idlType\": \"RegExp\"\n        },\n        \"name\": \"regexp\",\n        \"extAttrs\": []\n    }\n    \nThe fields are as follows:\n\n* `type`: Always \"attribute\".\n* `name`: The attribute's name.\n* `static`: True if it's a static attribute.\n* `stringifier`: True if it's a stringifier attribute.\n* `inherit`: True if it's an inherit attribute.\n* `readonly`: True if it's a read-only attribute.\n* `idlType`: An [IDL Type](#idl-type) for the attribute.\n* `extAttrs`: A list of [extended attributes](#extended-attributes).\n\n### Constant Member\n\nA constant member looks like this:\n\n    {\n        \"type\": \"const\",\n        \"nullable\": false,\n        \"idlType\": \"boolean\",\n        \"name\": \"DEBUG\",\n        \"value\": {\n            \"type\": \"boolean\",\n            \"value\": false\n        },\n        \"extAttrs\": []\n    }\n\nThe fields are as follows:\n\n* `type`: Always \"const\".\n* `nullable`: Whether its type is nullable.\n* `idlType`: The type of the constant (a simple type, the type name).\n* `name`: The name of the constant.\n* `value`: The constant value as described by [Const Values](#default-and-const-values)\n* `extAttrs`: A list of [extended attributes](#extended-attributes).\n\n### Serializer Member\n\nSerializers come in many shapes, which are best understood by looking at the\nexamples below that map the IDL to the produced AST.\n\n    // serializer;\n    {\n        \"type\": \"serializer\",\n        \"extAttrs\": []\n    }\n\n    // serializer DOMString serialize();\n    {\n        \"type\": \"serializer\",\n        \"idlType\": {\n            \"sequence\": false,\n            \"generic\": null,\n            \"nullable\": false,\n            \"array\": false,\n            \"union\": false,\n            \"idlType\": \"DOMString\"\n        },\n        \"operation\": {\n            \"name\": \"serialize\",\n            \"arguments\": []\n        },\n        \"extAttrs\": []\n    }\n\n    // serializer = { from, to, amount, description };\n    {\n        \"type\": \"serializer\",\n        \"patternMap\": true,\n        \"names\": [\n            \"from\",\n            \"to\",\n            \"amount\",\n            \"description\"\n        ],\n        \"extAttrs\": []\n    }\n\n    // serializer = number;\n    {\n        \"type\": \"serializer\",\n        \"name\": \"number\",\n        \"extAttrs\": []\n    }\n\n    // serializer = [ name, number ];\n    {\n        \"type\": \"serializer\",\n        \"patternList\": true,\n        \"names\": [\n            \"name\",\n            \"number\"\n        ],\n        \"extAttrs\": []\n    }\n\nThe common fields are as follows:\n\n* `type`: Always \"serializer\".\n* `extAttrs`: A list of [extended attributes](#extended-attributes).\n\nFor a simple serializer, that's all there is. If the serializer is an operation, it will\nhave:\n\n* `idlType`: An [IDL Type](#idl-type) describing what the serializer returns.\n* `operation`: An object with the following fields:\n    * `name`: The name of the operation.\n    * `arguments`: An array of [arguments](#arguments) for the operation.\n\nIf the serializer is a pattern map:\n\n* `patternMap`: Always true.\n* `names`: An array of names in the pattern map.\n\nIf the serializer is a pattern list:\n\n* `patternList`: Always true.\n* `names`: An array of names in the pattern list.\n\nFinally, if the serializer is a named serializer:\n\n* `name`: The serializer's name.\n\n### Iterator Member\n\nIterator members look like this\n\n    {\n        \"type\": \"iterator\",\n        \"getter\": false,\n        \"setter\": false,\n        \"creator\": false,\n        \"deleter\": false,\n        \"legacycaller\": false,\n        \"static\": false,\n        \"stringifier\": false,\n        \"idlType\": {\n            \"sequence\": false,\n            \"generic\": null,\n            \"nullable\": false,\n            \"array\": false,\n            \"union\": false,\n            \"idlType\": \"Session2\"\n        },\n        \"iteratorObject\": \"SessionIterator\",\n        \"extAttrs\": []\n    }\n\n* `type`: Always \"iterator\".\n* `iteratorObject`: The string on the right-hand side; absent if there isn't one.\n* the rest: same as on [operations](#operation-member).\n\n### Arguments\n\nThe arguments (e.g. for an operation) look like this:\n\n    \"arguments\": [\n        {\n            \"optional\": false,\n            \"variadic\": true,\n            \"extAttrs\": [],\n            \"idlType\": {\n                \"sequence\": false,\n                \"generic\": null,\n                \"nullable\": false,\n                \"array\": false,\n                \"union\": false,\n                \"idlType\": \"long\"\n            },\n            \"name\": \"ints\"\n        }\n    ]\n\nThe fields are as follows:\n\n* `optional`: True if the argument is optional.\n* `variadic`: True if the argument is variadic.\n* `idlType`: An [IDL Type](#idl-type) describing the type of the argument.\n* `name`: The argument's name.\n* `extAttrs`: A list of [extended attributes](#extended-attributes).\n\n### Extended Attributes\n\nExtended attributes are arrays of items that look like this:\n\n    \"extAttrs\": [\n        {\n            \"name\": \"TreatNullAs\",\n            \"arguments\": null,\n            \"rhs\": {\n                \"type\": \"identifier\",\n                \"value\": \"EmptyString\"\n            }\n        }\n    ]\n\nThe fields are as follows:\n\n* `name`: The extended attribute's name.\n* `arguments`: If the extended attribute takes arguments (e.g. `[Foo()]`) or if\n  its right-hand side does (e.g. `[NamedConstructor=Name(DOMString blah)]`) they\n  are listed here. Note that an empty arguments list will produce an empty array,\n  whereas the lack thereof will yield a `null`. If there is an `rhs` field then\n  they are the right-hand side's arguments, otherwise they apply to the extended\n  attribute directly.\n* `rhs`: If there is a right-hand side, this will capture its `type` (which can be\n  \"identifier\" or \"identifier-list\") and its `value`.\n* `typePair`: If the extended attribute is a `MapClass` this will capture the\n  map's key type and value type respectively.\n\n### Default and Const Values\n\nDictionary fields and operation arguments can take default values, and constants take\nvalues, all of which have the following fields:\n\n* `type`: One of string, number, boolean, null, Infinity, NaN, or sequence.\n\nFor string, number, boolean, and sequence:\n\n* `value`: The value of the given type. For sequence, the only possible value is `[]`.\n\nFor Infinity:\n\n* `negative`: Boolean indicating whether this is negative Infinity or not.\n\n### `iterable<>`, `legacyiterable<>`, `maplike<>`, `setlike<>` declarations\n\nThese appear as members of interfaces that look like this:\n\n        {\n            \"type\": \"maplike\", // or \"legacyiterable\" / \"iterable\" / \"setlike\"\n            \"idlType\": /* One or two types */,\n            \"readonly\": false, // only for maplike and setlike\n            \"extAttrs\": []\n        }\n\nThe fields are as follows:\n\n* `type`: Always one of \"iterable\", \"legacyiterable\", \"maplike\" or \"setlike\".\n* `idlType`: An [IDL Type](#idl-type) (or an array of two types) representing the declared type arguments.\n* `readonly`: Whether the maplike or setlike is declared as read only.\n* `extAttrs`: A list of [extended attributes](#extended-attributes).\n\n\nTesting\n=======\n\nIn order to run the tests you need to ensure that the widlproc submodule inside `test` is\ninitialised and up to date:\n\n    git submodule init\n    git submodule update\n\nRunning\n-------\nThe test runs with mocha and expect.js. Normally, running mocha in the root directory\nshould be enough once you're set up.\n\nCoverage\n--------\nCurrent test coverage, as documented in `coverage.html`, is 95%. You can run your own\ncoverage analysis with:\n\n    jscoverage lib lib-cov\n    \nThat will create the lib-cov directory with instrumented code; the test suite knows\nto use that if needed. You can then run the tests with:\n\n    JSCOV=1 mocha --reporter html-cov > coverage.html\n\nNote that I've been getting weirdly overescaped results from the html-cov reporter,\nso you might wish to try this instead:\n\n    JSCOV=1 mocha  --reporter html-cov | sed \"s/&lt;/</g\" | sed \"s/&gt;/>/g\" | sed \"s/&quot;/\\\"/g\" > coverage.html\n\nBrowser tests\n-------------\nIn order to test in the browser, get inside `test/web` and run `make-web-tests.js`. This\nwill generate a `browser-tests.html` file that you can open in a browser. As of this\nwriting tests pass in the latest Firefox, Chrome, Opera, and Safari. Testing on IE\nand older versions will happen progressively.\n\nTODO\n====\n\n* add some tests to address coverage limitations\n* add a push API for processors that need to process things like comments\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/darobin/webidl2.js/issues"
  },
  "_id": "webidl2@2.0.11",
  "dist": {
    "shasum": "dfdeffc4fca35f7d63d36480494a2d8776ac20d4"
  },
  "_from": "webidl2@",
  "_resolved": "https://registry.npmjs.org/webidl2/-/webidl2-2.0.11.tgz"
}
